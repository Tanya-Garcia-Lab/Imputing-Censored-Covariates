#' Fit a linear model to a list of imputed datasets
#'
#' Takes a list of imputed datasets, as generated by \code{condl_mean_impute_bootstrap()},
#' and returns a list which summarizes estimation of the \code{p} regression coefficients
#' 
#' @param imputed_list A list with dataframe elements that have been completed via conditional mean imputation, such as by \code{condl_mean_impute_bootstrap()}. 
#' @param formula A formula object used to fit a linear model to each dataframe in \code{imputed_list}
#' 
#' @return A list with the following three elements:
#' \item{Coef}{A vector of the \code{p} average coefficient estimates obtained from fitting \code{formula} to each dataframe in \code{imputed_list}}
#' \item{Var}{A vector of the \code{p} average variance estimates obtained from fitting \code{formula} to each dataframe in \code{imputed_list}}
#' \item{Pooled_Var}{A vector of the \code{p} pooled variance estimates, calculated using Rubin's rules}
#' 
#' @export
fit_lm_to_imputed_list = function(imputed_list, formula) {
  # test for bad input
  # are all elements of imputed_list a data.frame or matrix?
  if (!all(unlist(lapply(imputed_list, function(x) (is.data.frame(x) | is.matrix(x)))))) { stop("elements of imputed_list must be data.frame or matrix")}
  # do all elements of imputed_list contain columns needed for formula?
  if (!all(unlist(lapply(imputed_list, function(x) (all.vars(formula) %in% colnames(x)))))) { stop("elements of imputed_list do not contain columns needed for formula")}
  
  # determine number of bootstrap samples
  M = length(imputed_list)
  
  # get list of length M, with each entry a vector of coefficient and SE estimates
  estimates_list <- lapply(X = imputed_list, 
                           FUN = function(x) {
                             model <- lm(formula = formula, data = x)
                             estimates <- c(model$coefficients, diag(vcov(model)))
                           })
  
  # capture number of parameters
  p <- length(estimates_list[[1]])/2

  # collapse list of parameter estimates into M x p matrix
  coef_matrix <- matrix(0, nrow = M, ncol = p)
  var_matrix <- matrix(0, nrow = M, ncol = p)
  for (i in 1:M) { 
    coef_matrix[i, ] <- estimates_list[[i]][1:p]
    var_matrix[i, ] <- estimates_list[[i]][-(1:p)]
  }
  # name columns
  dimnames(coef_matrix)[[2]] <- dimnames(var_matrix)[[2]] <- names(estimates_list[[1]])[1:p]
  
  # calcualte the average within-imputation variance
  within_imp_var <- colMeans(var_matrix)
  # calculate the total imputation variance according to Rubin's rules
  total_imp_var <- within_imp_var + (1 + 1/M)*apply(coef_matrix, 2, var)
  
  # return column means
  list(Coef = colMeans(coef_matrix), 
       Var = within_imp_var,
       Pooled_Var = total_imp_var)
}

# # generate sample data and KM fit for test
# sample.data <- generate_data(n = 500, n.sims = 1, beta0 = 0, betaX = 1)
# sample.fit <- with(sample.data, survival::survfit(formula = survival::Surv(x, event) ~ 1))
# # perform conditional mean imputation
# imp.sample.data <- condl_mean_impute_bootstrap(fit = sample.fit, obs = "t", event = "event",
#                                                data = sample.data, M = 20)
# fit_lm_to_imputed_list(imputed_list = imp.sample.data, formula = as.formula(y ~ imp))
# fit_lm_to_imputed_list(imputed_list = imp.sample.data, formula = as.formula(y ~ s))
